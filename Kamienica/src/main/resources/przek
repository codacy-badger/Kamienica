create or replace package body smok.PRZEKAZY_PROCES is

Type TT_ID IS TABLE OF NUMBER(12) index by binary_INTEGER;
listaIDPrzekazow TT_ID;
sKatalog varchar(40)  := MISC.GET_VPARAM.UTL_FILE_VALUE;
punktGraniczny NUMBER;
--xmlTag VARCHAR2(50) := '<?xml version="1.0" encoding="iso-8859-2" ?>' ||chr(13);
idProcesu NUMBER;
licznikBledow NUMBER;
idBledu NUMBER := 1;
plikXML  utl_file.file_type;
error VARCHAR2(50);
skok NUMBER;
stopMarker BOOLEAN := true;


SUBTYPE tr_tmp IS SMOK.PRZEKAZY_POCZTOWE%rowtype;
TYPE tt_tmp is table of tr_tmp index by binary_INTEGER;

-----------------------------GENEROWANIE-NAZWY-PLIKU--------------------------------
FUNCTION generujNazwePliku(nazwaKlienta IN VARCHAR2) RETURN VARCHAR2
  IS
  dataCzas VARCHAR(13) := TO_CHAR(sysdate, 'YYMMDD_HH24MiSS');
  output varchar(30);
  BEGIN
    output := dataCzas || '_' || nazwaKlienta ||  '.xml';
    RETURN(output);
  EXCEPTION
  WHEN OTHERS THEN
     dbms_output.put_line(sqlerrm || CHR(10) || 'generujNazwePliku');
  END generujNazwePliku;

-------------------------------------LADOWANIE LISTY PRZEKAZOW------------------------
PROCEDURE pobierzIDPrzekazow(data DATE)
 IS
  BEGIN
    SELECT  ID  BULK COLLECT into listaIDPrzekazow from SMOK.PRZEKAZY_POCZTOWE where DATA_PRZEKAZU = trunc(data);
  EXCEPTION
  WHEN OTHERS THEN
     WSP.PROCESY.error('Brak danych do załadowania',0  ,0);
     dbms_output.put_line(sqlerrm || CHR(10) || 'pobierzIDPrzekazow');

 END pobierzIDPrzekazow;
 -----------------------------------PRZYGOTOWANIE PLIKU LOGOWANIA-----------------------------
 PROCEDURE przygotujLoga (log IN OUT WSP.PROCESY_LOG%rowtype )IS
   BEGIN
     log.data_proc := trunc(sysdate);
     log.data_start := sysdate;
     log.id := WSP.PROCESY_LOG_ID.NEXTVAL;
     log.il_bledow := 0;
     log.il_trans :=0;
     log.il_umow :=0;
     log.nr_podproc := null;
     log.ile_podproc := null;
     log.info := 'Generowanie przekazow pocztowych';
     log.nr_klasy := null;
     log.nr_podproc := null;
     log.proces := 'PRZEK_POCZ_PROCES';

     idProcesu := log.id;
   END przygotujLoga;
-----------------------------wstawLogaDoBazy----------------------------------
PROCEDURE wstawLoga (log IN WSP.Procesy_Log%rowtype) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO WSP.PROCESY_LOG(  DATA_END, DATA_PROC, data_start,id, IL_BLEDOW, IL_TRANS, INFO, PROCEs )
        VALUES(log.data_end, log.data_proc, log.data_start, log.id, log.il_bledow, log.il_trans, log.info, log.proces);

        COMMIT;
    END wstawLoga;

-----------------------------wstawError----------------------------------
PROCEDURE wstawError (tekst VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      INSERT INTO WSP.PROCESY_ERROR(id, ID_BLEDU, proces, data_rej, INFO) values
      (idProcesu, idBledu, 'PRZEK_POCZ_PROCES', sysdate, tekst);
      COMMIT;
      licznikBledow := licznikBledow +1;
      idBledu := idBledu +1;
    END wstawError;
------------------------ORANAZWA-----------------------------------------
FUNCTION getORAnazwa(nrUmowy NUMBER) RETURN VARCHAR2 IS
  output  VARCHAR2(50);
  BEGIN
    select ok.oranazwa into output from smok.smok_x sx, smok.oraklasy ok 
    where ID_ROW LIKE lpad(nrUmowy, 10) || '%'
    and sx.nr_klasy = ok.nr_klasy;
    return output;
  END getORAnazwa;  
 ---------------------------NOTATKA PRZEKAZU---------------------------
 Function NotatkaPrzekazu(KWOTA_NADPLATY NUMBER, OPLATA_ZA_PRZEKAZ NUMBER, KOSZTY_BANKU NUMBER) RETURN VARCHAR2 IS
   NotatkaPrzekazu VARCHAR2(200);
   kwota NUMBER;
    BEGIN
      If KOSZTY_BANKU = 1 THEN
        NotatkaPrzekazu := ' odesł. kw. ' || KWOTA_NADPLATY || ' przekaz. poczt., bez potrącenia kosztów, ';
      Else
        kwota := KWOTA_NADPLATY - OPLATA_ZA_PRZEKAZ;
        NotatkaPrzekazu := ' odesł. kw. ' || kwota || ' przekaz. poczt., po potr. kosztów przekazu, ';
      End If;
    return NotatkaPrzekazu;
    EXCEPTION
      when others then
        dbms_output.put_line(' notatka przekazu  -> ' || sqlerrm);
End NotatkaPrzekazu;
-----------------------------ZAPIS NOTATKI--------------------------------
PROCEDURE zapiszNotatke(przesylka SMOK.PRZEKAZY_POCZTOWE%rowtype) IS
  l_sql VARCHAR2(300);
  l_oranazwa VARCHAR2(50) :=getORAnazwa(przesylka.numer_umowy);
  l_tresc VARCHAR(200);
  errmsg VARCHAR2(10);
  BEGIN
   errmsg :='1'; 
  l_tresc := '@187' || NotatkaPrzekazu(przesylka.kwota_nadplaty, przesylka.oplata_za_przekaz, przesylka.koszty_banku);
  
 
    if(l_oranazwa <> 'VISION') THEN
    errmsg :='2'; 
--                                                       "@187" & NotatkaPrzekazu(rs.Fields("KWOTA_NADPLATY"), rs.Fields("OPLATA_ZA_PRZEKAZ"), rs.Fields("KOSZTY_BANKU")
      l_sql := 'BEGIN '||l_oranazwa||'.CLIPPERTABLES.NOTATKI_INSERT(:l_nr_zlec, :l_filia,'''||l_tresc ||'''); END;';
      EXECUTE IMMEDIATE l_sql USING TO_NUMBER( substr(przesylka.numer_umowy,1,7) ), substr(przesylka.numer_umowy,8,3) ;
    END IF;
EXCEPTION
     WHEN OTHERS THEN
    dbms_output.put_line('wykrzaczylo dla: ' || przesylka.numer_umowy || 'PUNKT: '|| errmsg || '  -> ' || sqlerrm);
     
  END zapiszNotatke;

------------TWORZ-ATRYBUT-PRZESYLKI--------------------------
FUNCTION tworzAtrybut(typ IN VARCHAR2, nazwa IN VARCHAR2, wartosc IN VARCHAR2) RETURN VARCHAR2
 IS
 tekst VARCHAR2(200);
  BEGIN
    tekst := '<Atrybut Typ="'||  typ ||'" Nazwa="' || nazwa ||'">' || wartosc || '</Atrybut>' ||chr(13);
    RETURN(tekst);
  END tworzAtrybut;

--------------------------------WALIDACJA DANYCH WEJSCIOWYCH-----------------------------------------
FUNCTION walidujWpis (doWalidacji SMOK.PRZEKAZY_POCZTOWE%rowtype) RETURN BOOLEAN IS
  brakujaceDane EXCEPTION;
  msg VARCHAR2(250) := 'Nieznany blad';
  BEGIN
    IF doWalidacji.Kod_Pocztowy is NULL OR LENGTH(doWalidacji.Kod_Pocztowy)<>6 THEN
      msg := 'Nieprawidłowy kod pocztowy dla id: ' || doWalidacji.id;
      RAISE brakujaceDane;
    END IF;

    IF doWalidacji.Imie IS NULL OR doWalidacji.Nazwisko is NULL  THEN
      msg := 'Nieprawidłowe imię/nazwisko dla id: ' || doWalidacji.id;
      RAISE brakujaceDane;
    END IF;

    IF doWalidacji.Miejscowosc IS NULL OR doWalidacji.Adres is NULL  THEN
      msg := 'Nieprawidłowe  adres/miejscowosc dla id: ' || doWalidacji.id;
      RAISE brakujaceDane;
    END IF;

    RETURN TRUE;
    EXCEPTION
    WHEN brakujaceDane THEN
    dbms_output.put_line(sqlerrm  || '-> ' ||msg);
    wstawError(msg);

    RETURN FALSE;
END walidujWpis;
--------------------getCurrent version---------------------------------

FUNCTION get_version RETURN VARCHAR2 AS
   tmp_version VARCHAR2(100);
BEGIN
   SELECT gl_version || ' - CREATED:' ||
            TO_CHAR(MIN(created),
                  'yyyy-mm-dd hh24:mi:ss') || ' COMPILED:' ||
            TO_CHAR(MIN(last_ddl_time),
                  'yyyy-mm-dd hh24:mi:ss')
   INTO   tmp_version
      FROM   user_objects
      WHERE  object_name = 'SMOK'
        AND  object_type = 'PACKAGE';
   RETURN(tmp_version);
END get_version;

-------------GE PARAMETRY----------------------------------------------------------
FUNCTION GetGE_PARAMETRY return varchar2 is
  c varchar2(100);
  msgNum number;
  rvb boolean;
begin
  SELECT wartosc into c
    FROM adminx.ge_parametry
   WHERE kod_sys=1
     AND zestaw=(SELECT TO_NUMBER(wartosc)
    FROM adminx.ge_parametry
   WHERE kod_sys=1 AND zestaw=0 AND zmienna_param='PRZEKAZY_POCZTOWE_SKOK')
     AND zmienna_param='PRZEKAZY_POCZTOWE_SKOK';
  return trim(c);
exception
  when others then
     wstawError('Brak nadawcy w ADMINX.GE_PARAMETRY');
    return null;
end;

---------------Dodaj Atrybut zbioru przesyłek------------
  FUNCTION addAtribute(l_domdoc IN xmldom.DOMDocument, fatherNode IN dbms_xmldom.DOMNode, NAZWA IN VARCHAR2, TYP IN VARCHAR2, WARTOSC IN VARCHAR2) RETURN dbms_xmldom.DOMElement IS
  atrybutElement dbms_xmldom.DOMElement;
   atrybutNode dbms_xmldom.DOMNode;
   atrybutText dbms_xmldom.DOMText;
   atrybutTextnode dbms_xmldom.DOMNode;
  BEGIN
     atrybutElement := dbms_xmldom.createElement(l_domdoc, 'Atrybut' ); 
     dbms_xmldom.setAttribute(atrybutElement, 'Typ', TYP);
     dbms_xmldom.setAttribute(atrybutElement, 'Nazwa', NAZWA);
     atrybutNode := dbms_xmldom.appendChild(fatherNode,dbms_xmldom.makeNode(atrybutElement));
     atrybutText := dbms_xmldom.createTextNode(l_domdoc, WARTOSC );
     atrybutTextnode := dbms_xmldom.appendChild(atrybutNode,dbms_xmldom.makeNode(atrybutText));
    RETURN atrybutElement;
  END addAtribute;
  ----------------------------------------------------------
  ---------------Dodaj Atrybut zbioru przesyłek------------
  FUNCTION dodajPrzesylke(l_domdoc IN xmldom.DOMDocument, fatherNode IN dbms_xmldom.DOMNode, przesylka SMOK.PRZEKAZY_POCZTOWE%rowtype) RETURN dbms_xmldom.DOMElement IS
  przesylkaElement dbms_xmldom.DOMElement;
  przesylkaNode dbms_xmldom.DOMNode;
  atrybutElement dbms_xmldom.DOMElement;

  dom VARCHAR2(10);
  lokal VARCHAR2(10);
  indexZnaku NUMBER;
  BEGIN

     dom := regexp_substr(przesylka.adres, '[0-9]+\D*+\d*');
     indexZnaku :=  instr(dom,'/',1);
         IF(indexZnaku <> 0) THEN
            lokal := substr(dom,  (indexZnaku + 1));
            dom := substr(dom, 1, (indexZnaku - 1));
         end If;
   przesylkaElement := dbms_xmldom.createElement(l_domdoc, 'Przesylka' );
   przesylkaNode := dbms_xmldom.appendChild(fatherNode,dbms_xmldom.makeNode(przesylkaElement));

   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Symbol', null, '180');
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Wersja', null, '1');
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Wartosc', null, przesylka.kwota_nadplaty*100);
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Nazwa', 'Adresat',  przesylka.nazwisko || ' ' || przesylka.imie);
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Rodzaj', 'Adresat', 'N');
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Ulica',  'Adresat',trim(regexp_substr(przesylka.adres, '\D+')));


   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Dom' , 'Adresat',  dom);
   IF(lokal is not null ) THEN
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Lokal' ,'Adresat',  lokal);
   END IF;
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Miejscowosc' ,'Adresat',  przesylka.miejscowosc);
   atrybutElement := addAtribute(l_domdoc , przesylkaNode, 'Kod' , 'Adresat',  Substr(przesylka.kod_pocztowy, 1,2) || Substr(przesylka.kod_pocztowy, 4,3));
  --zapis notatek
   zapiszNotatke(przesylka);
  
   return przesylkaElement;

  END dodajPrzesylke;
----------------------------GENERUJ PLIK XML-------------------------------------
  FUNCTION generujXML(tabelaTMP tt_tmp, indexStart NUMBER) RETURN XMLTYPE IS
   l_xmltype XMLTYPE;
   l_domdoc dbms_xmldom.DOMDocument;
   l_root_node dbms_xmldom.DOMNode;

   nadawcaElement dbms_xmldom.DOMElement;
   nadawcaNode dbms_xmldom.DOMNode;

   zbiorElement dbms_xmldom.DOMElement;
   zbiorNode dbms_xmldom.DOMNode;

   przesylkaElement dbms_xmldom.DOMElement;

   indexStop NUMBER;
BEGIN
   IF(punktGraniczny < tabelaTMP.count() )
   THEN indexStop := punktGraniczny;
   ELSE indexStop := tabelaTMP.count();
 END IF;

   l_domdoc := dbms_xmldom.newDomDocument;

   xmldom.setVersion( l_domdoc, '1.0" encoding="iso-8859-2' );
   xmldom.setCharset( l_domdoc, 'iso-8859-2' );

   l_root_node := dbms_xmldom.makeNode(l_domdoc);

   nadawcaElement := dbms_xmldom.createElement(l_domdoc, 'Nadawca' );
         dbms_xmldom.setAttribute(nadawcaElement, 'Struktura', '1.7');
         dbms_xmldom.setAttribute(nadawcaElement, 'Nazwa', 'Bank BPH Spółka Akcyjna');
         dbms_xmldom.setAttribute(nadawcaElement, 'NazwaSkrocona', 'BPH');
         dbms_xmldom.setAttribute(nadawcaElement, 'Miejscowosc', 'Gdańsk');
         dbms_xmldom.setAttribute(nadawcaElement, 'Ulica', 'płk. Jana Pałubickiego');
         dbms_xmldom.setAttribute(nadawcaElement, 'Dom', '2');
         dbms_xmldom.setAttribute(nadawcaElement, 'Kod', '80175');
         dbms_xmldom.setAttribute(nadawcaElement, 'NumerTelefonu', '');
         dbms_xmldom.setAttribute(nadawcaElement, 'Email', '');

   nadawcaNode := dbms_xmldom.appendChild(l_root_node,dbms_xmldom.makeNode(nadawcaElement));

   zbiorElement := dbms_xmldom.createElement(l_domdoc, 'Zbior' );
   zbiorNode := dbms_xmldom.appendChild(nadawcaNode,dbms_xmldom.makeNode(zbiorElement));


   FOR index_proc IN  indexStart..indexStop LOOP
       IF(walidujWpis(tabelaTMP(index_proc))) THEN
             przesylkaElement := dodajPrzesylke(l_domdoc , zbiorNode, tabelaTMP(index_proc)) ;
       END if;
   END LOOP;
   -- l_xmltype := xmldom.getxmltype(l_domdoc);
   l_xmltype := dbms_xmldom.getXmlType(l_domdoc);
   -- dbms_xmldom.freeDocument(l_domdoc);



   return l_xmltype;
END generujXML;

------------------------ZAMKNIJ PLIK---------------------------------------------------
PROCEDURE zamknijPlik IS
  BEGIN

    IF UTL_FILE.is_open(plikXML) THEN
      UTL_FILE.FCLOSE(plikXML);
    END IF;
  END zamknijPlik;
------------------------OTWORZ PLIK-------------------------------------------------------------
 PROCEDURE otworzPlik( nazwa NUMBER) IS
  BEGIN
    plikXML := UTL_FILE.FOPEN(sKatalog, generujNazwePliku('BANKBPHSA' || CHR(nazwa)), 'W', 4000);
  END otworzPlik;
------------------------GDY LICZBA PRZEKAZOW PRZEKRACZA MAKSYMALNY DOPUSZCZALNY ROZMIAR------------------
PROCEDURE rekordGraniczny( nazwa NUMBER, skok NUMBER) IS
  BEGIN
    punktGraniczny := punktGraniczny + skok;
    zamknijPlik;
    otworzPlik(nazwa);
END rekordGraniczny;

-----------------------------GENEROWANIE-PRZERKAZOW-------------------------------------------------------
PROCEDURE przekazPocztowyProces(data DATE DEFAULT SYSDATE) IS
nrPliku NUMBER;
log WSP.PROCESY_LOG%rowtype;
brakDanych EXCEPTION;
l_xmltype XMLTYPE;
indexStart NUMBER := 1;
tabelaTMP tt_tmp;
--l_oranazwa VARCHAR2(50) := getORAnazwa;


  BEGIN
    select wartosc into skok from ADMINX.GE_PARAMETRY where zmienna_param ='PRZEKAZY_POCZTOWE_SKOK';
    pobierzIDPrzekazow(data);


   SELECT *  BULK COLLECT into tabelaTMP
   FROM SMOK.PRZEKAZY_POCZTOWE
   where DATA_PRZEKAZU = data
     AND STATUS is null;

   IF (tabelaTMP.count = 0) THEN
       RAISE brakDanych;
   END IF;


   przygotujLoga(log);
   nrPliku := 97;
   licznikBledow :=0;
   punktGraniczny := skok;

   log.il_trans := tabelaTMP.count;

   IF (tabelaTMP.count = 0) THEN
        dbms_output.put_line('koniec');
        stopMarker := false;
   END IF;


   while(indexStart <= tabelaTMP.count) LOOP
       error :='LOOP1 generujPrzesylke -> id ' || tabelaTMP(indexStart).id;
       otworzPlik(nrPliku);
       l_xmltype := generujXML(tabelaTMP, indexStart);
       --dbms_output.put_line('--------------------------');
       --dbms_output.put_line(l_xmltype.getClobVal);
       UTL_FILE.put_line(plikXML, l_xmltype.getClobVal);
       zamknijPlik;
       error :='Wstawianie xml do bazy ';
       INSERT into SMOK.PRZEKAZ_POCZ_PLIKI(DATA_WPROWADZENIA, plik) VALUES (sysdate,l_xmltype.getClobVal);
       punktGraniczny := punktGraniczny + skok;
       nrPliku := nrPliku +1;
       indexStart := indexStart + skok;

   END LOOP;

   -- zrob update rekordow na bazie (ustaw status 'W')
   -- notatka TODO
   UPDATE smok.Przekazy_Pocztowe
    SET STATUS = 'W'
    WHERE DATA_PRZEKAZU = data;

   COMMIT;

   zamknijPlik;

   log.data_end := sysdate;
   log.il_bledow := licznikBledow;
   wstawLoga(log);
  EXCEPTION
  WHEN brakDanych THEN
    dbms_output.put_line(sqlerrm || 'Brak danych do przetwarzania' );
  WHEN OTHERS THEN
    dbms_output.put_line(sqlerrm || CHR(10) || error);
    zamknijPlik;
  END przekazPocztowyProces;
end;
/*
select ok.oranazwa into l_oranazwa from smok.smok_x sx, smok.oraklasy ok 
where ID_ROW LIKE lpad('3652204100', 10) || '%'
and sx.nr_klasy = ok.nr_klasy;

l_sql := 'BEGIN '||l_oranazwa||'.CLIPPERTABLES.NOTATKI_INSERT(:l_nr_zlec, :l_filia,''@049 automatyczne zamknięcie umowy''); END;';
BEGIN
      EXECUTE IMMEDIATE l_sql USING TO_NUMBER( substr(IN_UMOWA,1,7) ), substr(IN_UMOWA,8,3) ;
EXCEPTION
      WHEN OTHERS THEN
      -- logowanie bledu
END;  
*/
create or replace package body vision.WPLATOMATY_PROCES is

  ------------------------ZMIENNE GLOBALNE---------------------------------------------
Type TT_ID IS TABLE OF NUMBER(12) index by binary_INTEGER;
LISTA_PROC TT_ID;

SUBTYPE tr_tmp IS VISION.TMP_WPLATOMAT_DATA%rowtype;
TYPE tt_tmp is table of tr_tmp index by binary_INTEGER;
TABELA_DLA_PROCESU tt_tmp;
errorPoint varchar2(50) :='OK';

SUBTYPE tr_rekordDoWbicia IS VISION.WPLATOMATY%rowtype;

nazwa_eliksir VARCHAR2(64) ;
nazwa_zgodnosc VARCHAR2(64);
nazwa_niezgodnosc VARCHAR2(64);
eliskir_fh  utl_file.file_type;
rap_zgodnosc_fh  utl_file.file_type;
rap_niezgodnosc_fh utl_file.file_type;
prowizja_fh utl_file.file_type;

--liczbaTransakcji NUMBER;
liczbaPoprawnychTransakcji NUMBER;
liczbaBlednychTransakcji NUMBER;
lacznaKwotaTransakcji NUMBER(17,2);
--lacznaKwotaTransakcjiZTrailera NUMBER;

--stopka/naglowek do raportow
lacznaPoprawnaKwotaTrans NUMBER(17,2);
lacznaNiepoprawnaKwotaTrans NUMBER(17,2);

kanal varchar2(40) :='KKWPLA';
usluga varchar2(40) :='KK_STAND';
  
geParam VARCHAR2(100);
--------------------getCurrent version---------------------------------
 /*
FUNCTION get_version RETURN VARCHAR2
IS
BEGIN
     RETURN (version);
END;
*/
-- Wersja pakietu
FUNCTION get_version RETURN VARCHAR2 AS
   tmp_version VARCHAR2(100);
BEGIN
   SELECT gl_version || ' - CREATED:' ||
            TO_CHAR(MIN(created),
                  'yyyy-mm-dd hh24:mi:ss') || ' COMPILED:' ||
            TO_CHAR(MIN(last_ddl_time),
                  'yyyy-mm-dd hh24:mi:ss')
   INTO   tmp_version
      FROM   user_objects
      WHERE  object_name = 'WPLATOMAT'
        AND  object_type = 'PACKAGE';
   RETURN(tmp_version);
END get_version;

---odczyt z GE_parametry; z Importer.pck-------------------------------------------------------------------
FUNCTION GetGE_PARAMETRY(cNazwaParametru in varchar2) return varchar2 is
  c varchar2(100);
  msgNum number;
  rvb boolean;
begin
  SELECT wartosc into c
    FROM adminx.ge_parametry
   WHERE kod_sys=1
     AND zestaw=(SELECT TO_NUMBER(wartosc)
    FROM adminx.ge_parametry
   WHERE kod_sys=1 AND zestaw=0 AND zmienna_param='GL_ZESTAW_PAR')
     AND zmienna_param=cNazwaParametru;
  return trim(c);
exception
  when others then
     msgNum := vision.pakpom.Inicjuj_Cp('WPLATOMAT_PROCESSING', 0, Null);
     vision.pakpom.ZapiszBlad('0', 'Brak nadawcy w ADMINX.GE_PARAMETRY');
     rvb := vision.pakpom.Zakoncz_Procesy_Log('00', 'NO GE PARAM ERROR');
    return null;
end;
----------------------------STWORZ NAGLOWEK i STOPKE DLA RAPORTOW ZGODNOSCI I NIEZG----------------------
--NAGL
FUNCTION tworzNaglowekRaportu(id NUMBER) return varchar2 is
  c varchar2(50);
begin
  SELECT ILOSC_TRANS ||'|' || SUMA_TRANS into c
    FROM vision.procesy_trailer
   WHERE ID_PROCESU=id;
  return c;
exception
  when others then
    return null;
end;
----STOPKA
/*
FUNCTION tworzStopkeRaportu(id NUMBER) return varchar2 is
  c varchar2(50);
begin
  SELECT ILOSC_TRANS ||'|' || SUMA_TRANS into c
    FROM vision.procesy_trailer
   WHERE ID_PROCESU=id;
  return c;
exception
  when others then
    return null;
end;
*/
--------------------------WALIDACJA DANYCH POBRANYCH Z PLIKU---------------------------------

procedure walidujRekord( doWalidacji IN OUT tr_rekordDoWbicia)
  IS
  blad exception;
  waludaException exception;
  msg varchar(90);
  BEGIN
   IF doWalidacji.Id IS NULL THEN
     msg := 'brak klucza glownego';
     RAISE blad;
   END IF;


   IF doWalidacji.Kwota IS NULL THEN
     msg := 'brak kwoty';
     RAISE blad;
   END IF;

   IF doWalidacji.Nr_Karty IS NULL THEN
     msg := 'brak numberu karty';
     RAISE blad;
   END IF;

   IF doWalidacji.Waluta IS NULL THEN
     msg := 'brak numeru waluty';
     RAISE blad;
   END IF;

   IF (doWalidacji.Waluta <> '985') THEN
     msg := 'kod waluty inny niz 985';
     doWalidacji.Status := '101';
     RAISE waludaException;
   END IF;

   IF doWalidacji.Id_Transakcji IS NULL THEN
     msg := 'brak numeru transakcji';
     RAISE blad;
   END IF;

   IF doWalidacji.Data_Transakcji IS NULL THEN
     msg := 'brak daty transakcji';
     RAISE blad;
   END IF;

   IF doWalidacji.Wplatomat_Id IS NULL THEN
     msg := 'brak id wplatomatu';
     RAISE blad;
   END if;

--     IF doWalidacji.Nr_Konta IS NULL
--       THEN
--       msg := 'brak nr konta';
--       RAISE blad;
--     END IF;

   IF doWalidacji.Wplatomat_Lok IS NULL THEN
     msg := 'brak lokalizacji wplatomatu';
     RAISE blad;
   END IF;

 EXCEPTION


  WHEN blad THEN
     liczbaBlednychTransakcji := liczbaBlednychTransakcji +1;
     doWalidacji.Status := '100';
     vision.pakpom.ZapiszBlad(doWalidacji.Umowa, 'walidujRekord: ' || msg);
  WHEN waludaException THEN
     liczbaBlednychTransakcji := liczbaBlednychTransakcji +1;
     doWalidacji.Status := '101';
     vision.pakpom.ZapiszBlad(doWalidacji.Umowa, 'walidujRekord: ' || msg);
  WHEN OTHERS THEN
     errorPoint  :='walidujRekord';
     vision.pakpom.ZapiszBlad(doWalidacji.Umowa, 'walidujRekord: blad1');
  END walidujRekord;

-------------------------------------LADOWANIE LISTY PROCESOW Z TABLICY TMP------------------------
FUNCTION get_lista_procesow RETURN NUMBER
IS
    process_count NUMBER;
BEGIN
    errorPoint :='LADOWANIE LISTY PROCESOW';
    SELECT DISTINCT ID_PROCESU  BULK COLLECT into LISTA_PROC from VISION.TMP_WPLATOMAT_DATA;
    process_count := lista_proc.count;

    RETURN process_count;
EXCEPTION
  WHEN OTHERS THEN
    RETURN -1;
    errorPoint  :='get_lista_procesow';

END get_lista_procesow;

-------------------------LADOWANIE TYMCZASOWEJ TABELI DLA DANEGO PROCESU--------------------

FUNCTION utworz_tymczasowa_tabele(id_proc NUMBER) RETURN NUMBER
         IS
process_count NUMBER;
BEGIN
    errorPoint :='LADOWANIE TYMCZASOWEJ TABELI';
    TABELA_DLA_PROCESU.delete;

    SELECT *  BULK COLLECT into TABELA_DLA_PROCESU
     from VISION.TMP_WPLATOMAT_DATA
    where ID_PROCESU = id_proc;

    process_count := lista_proc.count;

RETURN TABELA_DLA_PROCESU.count;
EXCEPTION
  WHEN OTHERS THEN
    RETURN -1;
END utworz_tymczasowa_tabele;

--------------------LADOWANIE ID KONTR ORAZ UMOWY---------------------------------

procedure ladujDaneZBanku( doZaladowania IN OUT tr_rekordDoWbicia)
  IS
  nazwaKlienta varchar(200);


    p_id         ko.tab_adresy.id%type;
    p_skrytka    ko.tab_adresy.skrytka%type;
    p_poczta     ko.tab_adresy.poczta%type;
    p_gmina      ko.tab_adresy.gmina%type;
    p_miasto     ko.tab_adresy.miasto%type;
    p_ulica      ko.tab_adresy.ulica%type;
    p_nr_dom ko.tab_adresy.nr_dom%type;
    p_nr_mieszk  ko.tab_adresy.nr_mieszk%type;
    p_kod   ko.tab_adresy.kod%type;
    p_miasto_format  varchar2(200);
    p_kod_format  varchar2(50);
    p_ulica_format  varchar2(200);

  BEGIN
    errorPoint :='LADOWANIE ID KONR1';
    IF
      --(doZaladowania.Status != '100') OR
        doZaladowania.Status is NULL OR
        doZaladowania.Status = '' THEN

     --pobranie nr umowy
     Select umowa into doZaladowania.Umowa from ko.tab_karty where nr_karty= doZaladowania.Nr_Karty;

    -- id uzytkownika karty i posiadacza/wlaociciela karty
    SELECT kp.tk_id_kontr         -- id_kontr posiadacza karty (firmy)
      INTO doZaladowania.Id_Kontr
      FROM ko.tab_powiazanie_umow ku,   -- wiersz uzytkownika
           ko.tab_powiazanie_umow kp    -- wiersz posiadacza/wlaociciela
     WHERE ku.umowa = doZaladowania.Umowa
       AND ku.nadrz_id = kp.id;

      SELECT NAZWA_PELNA
      INTO nazwaKlienta
      FROM KO.Tab_Gospodarcze tg
      WHERE tg.tk_id_kontr = doZaladowania.Id_Kontr
      AND rownum < 2;


      ko.kaos.vpl_getaddress_k(doZaladowania.Id_Kontr,
                                       p_id,
                                       p_kod,
                                       p_miasto,
                                       p_ulica,
                                       p_nr_dom,
                                       p_nr_mieszk,
                                       p_skrytka,
                                       p_poczta,
                                       p_gmina);



      p_kod_format    := Ko.Kaos.formatKod(Ko.Kaos.make_kod(p_kod));
      p_miasto_format := Ko.Kaos.formatMiasto(p_miasto, p_poczta, p_gmina);
      p_ulica_format  := Ko.Kaos.formatUlica(p_skrytka, p_ulica, p_nr_dom, p_nr_mieszk);




     -- nazwaKlienta := Substr(nazwaKlienta, 1, 35) || '|';
     -- nazwaKlienta := nazwaKlienta || Substr(nazwaKlienta, 36, 35) || '|';
      nazwaKlienta := Substr(nazwaKlienta, 1, 35) || '|'|| Substr(nazwaKlienta, 36, 35) || '|';

      nazwaKlienta := nazwaKlienta || Substr(p_ulica_format, 1, 35) || '|';
      nazwaKlienta := nazwaKlienta || Substr(p_kod_format || ' ' || p_miasto_format, 1, 35);

      errorPoint :='LADOWANIE ID KONR2';

      doZaladowania.Dane_Odbiorcy := nazwaKlienta;
      doZaladowania.Nr_Nrb :=  rku.rejestr_umow.GET_NRB(doZaladowania.Umowa, '');

      doZaladowania.Status := '0';
   END IF;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       doZaladowania.Status := '103';
       liczbaBlednychTransakcji := liczbaBlednychTransakcji +1;
       vision.pakpom.ZapiszBlad('', 'ladujDaneZBanku: Nie mozna pobrac danych dla nr karty: '|| doZaladowania.Nr_Karty);
     WHEN OTHERS THEN
       liczbaBlednychTransakcji := liczbaBlednychTransakcji +1;
       vision.pakpom.ZapiszBlad('', errorPoint || ' ' || sqlerrm);

    END ladujDaneZBanku;
----------------------------GENEROWANIE NAZW DLA PLIKOW------------------------------------
procedure generujNazwyPlikow(idOstatniegoProc NUMBER)
  IS
  numerPliku number;
  dataGenerowaniaPliku varchar(15);
  BEGIN
    errorPoint :='GENEROWANIE NAZW DLA PLIKOW';
--liczba plikow na dany dzien
     select count(data_rej)+1 into numerPliku from vision.procesy_trailer where trunc(DATA_rej) = trunc(sysdate) AND id_procesu <= idOstatniegoProc;

     select to_char(sysdate, 'yyyymmdd_HH24Mi_') into dataGenerowaniaPliku from dual;

     nazwa_eliksir       :='EUR_WPL_' || dataGenerowaniaPliku || numerPliku || '.pli';
     nazwa_zgodnosc      :='EUR_WPL_' || dataGenerowaniaPliku || numerPliku || '_rpz.txt';
     nazwa_niezgodnosc   :='EUR_WPL_' || dataGenerowaniaPliku || numerPliku || '_rpn.txt';

  END generujNazwyPlikow;
 --------------------------WPROWADZANIE TRESCI DO PLIKOW------------------------------
procedure generujTekstRaportu(doZaraportowania IN  tr_rekordDoWbicia,  elisk IN OUT  utl_file.file_type,
  rap_zg  IN OUT utl_file.file_type ,  rap_nzg  IN OUT utl_file.file_type, liczbaTrans IN OUT NUMBER)
  IS
  tekstEliksir varchar2(500);
  tekstRaport varchar2(500);
  opisBledu varchar2(50);
  tytulWplaty varchar(200);
 BEGIN
     errorPoint :='TRESCI DO PLIKOW1';
     tekstRaport := 'WPLATA|' ||
     doZaraportowania.Nr_Karty || '|' ||
     doZaraportowania.Nr_Nrb || '|' ||
     doZaraportowania.Kwota || '|' ||
     doZaraportowania.Waluta || '|' ||
     doZaraportowania.Id_Transakcji || '|' ||
     to_char(doZaraportowania.Data_Transakcji, 'YYYYMMDD|HH24MiSS') || '|' ||
     doZaraportowania.Wplatomat_Id   || '|' ||
     doZaraportowania.Wplatomat_Lok || '|' ||
     doZaraportowania.Dane_Odbiorcy || '|' ;

     IF ( doZaraportowania.Status = '0' ) THEN

       tekstEliksir := '110' || ',' ||
       to_char(doZaraportowania.Data_Transakcji, 'YYYYMMDD') || ',' ||
       doZaraportowania.Kwota*100 || ',' ||
       SUBSTR(geParam,3,8) || ',' ||
       '0'  || ',' ||
       '"' || geParam || '"' || ',' ||
       '"' || doZaraportowania.Nr_Nrb  || '",' ||
       '"Bank BPH Spółka Akcyjna |ul. Jana Pałubickiego 2 |80-175 Gdańsk|"' || ',' ||
       '"' || doZaraportowania.Dane_Odbiorcy || '",' ||
       '0' || ',' ||
       substr(doZaraportowania.Nr_Nrb, 3, 8) || ',' ||
       '"Wpłata ' || to_char(doZaraportowania.Data_Transakcji, 'YYYYMMDD HH24Mi') || ' |ID ' ||
       doZaraportowania.Id_Transakcji;

       tytulWplaty := ' |Wpłatomat ' ||
       doZaraportowania.Wplatomat_Id ||
       doZaraportowania.Wplatomat_Lok;

       errorPoint :='TRESCI DO PLIKOW2';

       tekstEliksir := tekstEliksir ||
       substr(tytulWplaty, 1, 35) || '|' ||
       substr(tytulWplaty, 36, 35);

       tekstEliksir := tekstEliksir || '"';
       tekstEliksir := tekstEliksir || ',"","","51",""';

       UTL_FILE.put_line(eliskir_fh, tekstEliksir||chr(13));
       UTL_FILE.put_line(rap_zg, tekstRaport||chr(13));
       
       lacznaPoprawnaKwotaTrans := lacznaPoprawnaKwotaTrans + doZaraportowania.Kwota;
       liczbaTrans := liczbaTrans +1;
     ELSE
       errorPoint :='TRESCI DO PLIKOW3';
       select opis into opisBledu
        from vision.wplatomaty_slownik
       where kod = doZaraportowania.Status;

       tekstRaport := tekstRaport ||
       doZaraportowania.Status  || '|' ||
       opisBledu || '|';

       UTL_FILE.put_line(rap_nzg, tekstRaport||chr(13));
       lacznaNiepoprawnaKwotaTrans := lacznaNiepoprawnaKwotaTrans + doZaraportowania.Kwota;

     END IF;
   EXCEPTION
     WHEN OTHERS THEN
       liczbaBlednychTransakcji := liczbaBlednychTransakcji +1;
       vision.pakpom.ZapiszBlad(doZaraportowania.Umowa, errorPoint || ' ' || sqlerrm);
 END generujTekstRaportu;

 -------------------------------PROCESY_LOG-----------------------------------------------------
 FUNCTION genProcesyLog RETURN vision.procesy_log%ROWTYPE
   IS
   outLog vision.procesy_log%ROWTYPE;
   BEGIN
     errorPoint :='PROCESY_LOG';
     outLog.Data_Start := sysdate;
     --outLog.Id := vision.procesy_log_id.nextval;
     outLog.Il_Bledow := 0;
     outLog.Il_Trans := 0;
     outLog.Proces := 'WPLATOMAT_PROCESSING';
     outLog.Il_Umow :=0;
     outLog.Info := 'Wplatomat Euronet- przetwarzanie danych';
     outLog.Data_Proc := to_date(sysdate, 'yyyy-mm-dd');

   RETURN outLog;
   END genProcesyLog;
 -----------------------WALIDACJA_LACZNEJ_KWOTY--------------------------------------------------------

 PROCEDURE walidujLacznaKwote (idProcesu NUMBER)
   IS
   kwotaZTrailera  NUMBER;
   BEGIN
    errorPoint :='WALIDACJA_LACZNEJ_KWOTY';
    SELECT SUMA_TRANS INTO kwotaZTrailera
      FROM VISION.PROCESY_TRAILER pt
     WHERE pt.id_procesu = idProcesu;

    IF lacznaKwotaTransakcji <> kwotaZTrailera THEN
       vision.pakpom.ZapiszBlad('',  'Wyliczona kwota transakcji nie zgadza sie z kwota w trailerze');
    END IF;

   EXCEPTION WHEN OTHERS THEN
     dbms_output.put_line(sqlerrm);
     vision.pakpom.ZapiszBlad('', errorPoint || ' ' || sqlerrm);
   END walidujLacznaKwote;

--======================================================================================================
---------------------------PRZETWARZANIE DANYCH----------------------------------------------
PROCEDURE eksportEUR
  IS
  liczba_procesow NUMBER;
  tmp_rekord tr_tmp;

  doZapisu tr_rekordDoWbicia;
  sKatalog varchar(40)  := MISC.GET_VPARAM.UTL_FILE_VALUE;
  log vision.procesy_log%ROWTYPE;
  naglowekRaporty VARCHAR2(50);
  noGeParam exception;
  msgNum number;
  rvb boolean;
  BEGIN

    geParam := GetGE_PARAMETRY('WPLATOMATY_RACH_NAD');

    IF geParam IS NULL THEN
      RAISE noGeParam;
    END IF;

    liczba_procesow :=get_lista_procesow;

    FOR index_proc IN  1..liczba_procesow LOOP
      lacznaPoprawnaKwotaTrans := 0;
      lacznaNiepoprawnaKwotaTrans :=0;
      liczbaBlednychTransakcji :=0;
      lacznaKwotaTransakcji :=0;
      liczbaPoprawnychTransakcji:= 0;
      
      msgNum := vision.pakpom.Inicjuj_Cp('WPLATOMAT_PROCESSING', 0, Null);
      
      naglowekRaporty := tworzNaglowekRaportu(LISTA_PROC(index_proc));
      log.il_trans :=utworz_tymczasowa_tabele(LISTA_PROC(index_proc));
      
      log := genProcesyLog;
     
      generujNazwyPlikow(LISTA_PROC(index_proc));
      dbms_output.put_line(nazwa_zgodnosc);
      dbms_output.put_line(nazwa_niezgodnosc);
      
      eliskir_fh := UTL_FILE.FOPEN(sKatalog, nazwa_eliksir, 'W', 4000);
      
      rap_zgodnosc_fh := UTL_FILE.FOPEN(sKatalog, nazwa_zgodnosc, 'W', 4000);
      UTL_FILE.put_line(rap_zgodnosc_fh, naglowekRaporty||chr(13));
      
      rap_niezgodnosc_fh := UTL_FILE.FOPEN(sKatalog, nazwa_niezgodnosc, 'W', 4000);
      UTL_FILE.put_line(rap_niezgodnosc_fh, naglowekRaporty||chr(13));
      
      FOR index_tab IN  1..TABELA_DLA_PROCESU.count LOOP

        --zerowanie danych
        tmp_rekord :=TABELA_DLA_PROCESU(index_tab);
        doZapisu.Id := NULL;
        doZapisu.Kwota := NULL;
        doZapisu.Nr_Karty := NULL;
        doZapisu.Waluta := NULL;
        doZapisu.Id_Transakcji := NULL;
        doZapisu.Data_Transakcji := NULL;
        doZapisu.Wplatomat_Id := NULL;
        doZapisu.Wplatomat_Lok := NULL;
        doZapisu.Id_Procesu_Trailer := NULL;
        doZapisu.Nr_Konta := NULL;
        doZapisu.Data_Operacji := NULL;
        doZapisu.Dane_Odbiorcy := NULL;
        doZapisu.Id_Kontr := NULL;
        doZapisu.Nr_Banku_Odbiorcy := NULL;
        doZapisu.Nr_Nrb := NULL;
        doZapisu.Status := NULL;
        doZapisu.Umowa := NULL;
        doZapisu.Umowa_Profile := NULL;
        doZapisu.Wlasciciel_Rachunku := NULL;
        errorPoint :='PRZETWARZANIE1';
        --Przypisanie wartosci pobranych z pliku
        doZapisu.Id := vision.wplatomat_seq.nextval;
        doZapisu.Kwota := tmp_rekord.kwota;
        doZapisu.Nr_Karty := tmp_rekord.nr_karty;
        doZapisu.Waluta := tmp_rekord.kod_waluty;
        doZapisu.Id_Transakcji := tmp_rekord.id_transakcji;
        doZapisu.Data_Transakcji := tmp_rekord.data_transakcji;
        doZapisu.Wplatomat_Id := tmp_rekord.wplatomat_id;
        doZapisu.Wplatomat_Lok := tmp_rekord.wplatomat_lok;
        doZapisu.Id_Procesu_Trailer := tmp_rekord.id_procesu;
        doZapisu.Nr_Konta := tmp_rekord.nr_konta;
        doZapisu.Data_Operacji := sysdate;
        errorPoint :='PRZETWARZANIE2';
        lacznaKwotaTransakcji := lacznaKwotaTransakcji +doZapisu.Kwota;

        walidujRekord(doZapisu);
        errorPoint :='PRZETWARZANIE3';
        ladujDaneZBanku(doZapisu);

        generujTekstRaportu(doZapisu, eliskir_fh, rap_zgodnosc_fh, rap_niezgodnosc_fh, liczbaPoprawnychTransakcji);

        INSERT INTO vision.wplatomaty VALUES doZapisu;

        log.Il_Trans :=  log.Il_Trans +1;
        errorPoint :='PRZETWARZANIE4';
        DELETE FROM VISION.TMP_WPLATOMAT_DATA WHERE id= tmp_rekord.id;
      END LOOP;

      UTL_FILE.put_line(rap_zgodnosc_fh, liczbaPoprawnychTransakcji || '|' || lacznaPoprawnaKwotaTrans ||chr(13));
      UTL_FILE.put_line(rap_niezgodnosc_fh,liczbaBlednychTransakcji || '|' || lacznaniepoprawnaKwotaTrans ||chr(13));
  
      IF UTL_FILE.is_open(eliskir_fh) THEN
        UTL_FILE.FCLOSE(eliskir_fh);
        errorPoint :='PRZETWARZANIE5';
      END IF;

      IF UTL_FILE.is_open(rap_niezgodnosc_fh) THEN
        UTL_FILE.FCLOSE(rap_niezgodnosc_fh);
        errorPoint :='PRZETWARZANIE6';
      END IF;

      IF UTL_FILE.is_open(rap_zgodnosc_fh) THEN
        UTL_FILE.FCLOSE(rap_zgodnosc_fh);
        errorPoint :='PRZETWARZANIE7';
      END IF;

      errorPoint :='PRZETWARZANIE8';
      log.il_bledow := liczbaBlednychTransakcji;
      log.data_end := sysdate;
      walidujLacznaKwote(tmp_rekord.id_procesu);

      errorPoint :='PRZETWARZANIE9';
      rvb := vision.pakpom.Zakoncz_Procesy_Log(log.il_trans, 'OK', lacznaKwotaTransakcji );
      commit;
   END LOOP;

EXCEPTION
  WHEN noGeParam THEN
     dbms_output.put_line(sqlerrm);
     rvb := vision.pakpom.Zakoncz_Procesy_Log('00', 'NO GE PARAM ERROR');

      IF UTL_FILE.is_open(eliskir_fh) THEN
         UTL_FILE.FCLOSE(eliskir_fh);
      END IF;

      IF UTL_FILE.is_open(rap_niezgodnosc_fh) THEN
         UTL_FILE.FCLOSE(rap_niezgodnosc_fh);
      END IF;

      IF UTL_FILE.is_open(rap_zgodnosc_fh) THEN
         UTL_FILE.FCLOSE(rap_zgodnosc_fh);
      END IF;

  WHEN OTHERS THEN
     dbms_output.put_line(sqlerrm);
     vision.pakpom.ZapiszBlad(doZapisu.Umowa, errorPoint || sqlerrm);
     rvb := vision.pakpom.Zakoncz_Procesy_Log(doZapisu.Umowa, 'ERROR');

      IF UTL_FILE.is_open(eliskir_fh) THEN
         UTL_FILE.FCLOSE(eliskir_fh);
      END IF;

      IF UTL_FILE.is_open(rap_niezgodnosc_fh) THEN
         UTL_FILE.FCLOSE(rap_niezgodnosc_fh);
      END IF;

      IF UTL_FILE.is_open(rap_zgodnosc_fh) THEN
         UTL_FILE.FCLOSE(rap_zgodnosc_fh);
      END IF;
END eksportEUR;
----------------TWORZLINIJKE DLA SNO-----------------------------------------------
PROCEDURE wstawDaneSNO(NRB NUMBER, dataOperacji VARCHAR2) IS
  tekst VARCHAR2(100);
  liczbaOperacji NUMBER; 
  kwotaOperacji NUMBER(17,2) :=0;
  --01062016|320000538317|KKWPLA|KK_STAND|5|10000
BEGIN
  SELECT sum(KWOTA), count(KWOTA) INTO kwotaOperacji, liczbaOperacji FROM
  VISION.WPLATOMATY WHERE NR_NRB = NRB;
  tekst := dataOperacji || '|' ||
  SUBSTR(NRB, -12)  || '|' ||
  kanal || '|' ||
  usluga || '|' ||
  liczbaOperacji || '|' ||
  kwotaOperacji;
  --Dbms_Output.put_line(tekst);
  UTL_FILE.put_line(prowizja_fh, tekst||chr(13));
  EXCEPTION
    WHEN OTHERS THEN
    dbms_output.put_line(sqlerrm || ' wstawDaneSNO, NRB: ' || NRB);
END wstawDaneSNO;
-- ---------wer 2------------
PROCEDURE wstawDaneSNO2(wiersz VISION.WPLATOMATY%rowtype, dataOperacji VARCHAR2) IS
  tekst VARCHAR2(100);
  
  --01062016|320000538317|KKWPLA|KK_STAND|5|10000
BEGIN
  
  tekst := dataOperacji || '|' ||
  SUBSTR(wiersz.nr_nrb, -12)  || '|' ||
  kanal || '|' ||
  usluga || '|' ||
  1 || '|' ||
  wiersz.kwota;
  --Dbms_Output.put_line('teskt przed wbiciem do pliku: '|| tekst);
  UTL_FILE.put_line(prowizja_fh, tekst||chr(13));
  lacznaKwotaTransakcji := lacznaKwotaTransakcji +wiersz.kwota;
  EXCEPTION
    WHEN OTHERS THEN
    dbms_output.put_line(sqlerrm || ' wstawDaneSNO, NRB: ' || wiersz.nr_nrb);
    vision.pakpom.ZapiszBlad('', 'wstawDaneSNO, NRB:'||wiersz.nr_nrb || ' -> '  || sqlerrm);
END wstawDaneSNO2;
--------Przetwarzaj SNO-------------------------------------------------------------------
PROCEDURE generujRaportSNO( miesiac NUMBER,  rok NUMBER)
  IS
  SUBTYPE wierszWplatomat IS VISION.WPLATOMATY%rowtype;
  TYPE wplatomatTabelaTyp is table of wierszWplatomat index by binary_INTEGER;
  WPLATOMATY_TMP wplatomatTabelaTyp;

  Type TT_ID IS TABLE OF VARCHAR2(26) index by binary_INTEGER;
  listaUmow TT_ID;
  sKatalog varchar(40)  := MISC.GET_VPARAM.UTL_FILE_VALUE;
  blednyArgument Exception;
  brakDanych EXCEPTION;
  dataOperacji varchar2(40);
  nazwaPliku VARCHAR2(80) := 'F_' || kanal || '_' || usluga || '_' || rok; 
  dataStart DATE;
  dataKoniec DATE;
  error VARCHAR2(50);
  
  licznik NUMBER := 0;
  log vision.procesy_log%ROWTYPE;
  msgNum number;
  rvb boolean;
   
  BEGIN
   lacznaKwotaTransakcji := 0;
   msgNum := vision.pakpom.Inicjuj_Cp('WPLATOMAT_SNO', 0, Null);
   IF(miesiac < 1 OR miesiac > 12 OR rok <1990 or rok > 2100) THEN
    RAISE blednyArgument;
   END IF;
 
   IF (miesiac < 10) THEN
     dataStart := TO_DATE (rok || '0' || miesiac || '01 0000', 'yyyymmdd HH24Mi');
     dataKoniec := LAST_DAY( TO_DATE (rok || '0' || miesiac || '01 0000', 'yyyymmdd HH24Mi'));
     nazwaPliku := nazwaPliku || '0' || miesiac || '.TBS'; 
     dataOperacji  := '010'||miesiac||rok; 
   ELSE
     dataStart := TO_DATE (rok || miesiac || '01 0000', 'yyyymmdd HH24Mi');
     dataKoniec := LAST_DAY( TO_DATE (rok || miesiac || '01 0000', 'yyyymmdd HH24Mi'));
     nazwaPliku := nazwaPliku || miesiac || '.TBS';
     dataOperacji  := '01'||miesiac||rok;
   END IF;

   error := 'select';
   /*
   SELECT  DISTINCT NR_NRB  BULK COLLECT into listaUmow from VISION.WPLATOMATY 
   where DATA_TRANSAKCJI >=  dataStart
   AND DATA_TRANSAKCJI < dataKoniec+1 
   --LAST_DAY(to_date('04/04/1924','MM/DD/YYYY'))
   AND
   STATUS = '0';
   */
   SELECT   *  BULK COLLECT into WPLATOMATY_TMP from VISION.WPLATOMATY 
   where DATA_TRANSAKCJI >=  dataStart
   AND DATA_TRANSAKCJI < dataKoniec+1 
   --LAST_DAY(to_date('04/04/1924','MM/DD/YYYY'))
   AND
   STATUS = '0';
  /* 
   error := 'brak danych';
   IF (listaUmow.count = 0) THEN
     RAISE brakDanych;
   END IF;  
   */
   error := 'file open';
   prowizja_fh := UTL_FILE.FOPEN(sKatalog, nazwaPliku, 'W', 4000);
   
   error := 'wstawDaneSNO';
  /* FOR index_tab IN  1..listaUmow.count LOOP
     wstawDaneSNO(listaUmow(index_tab) , dataOperacji);
   END LOOP;
 */
    FOR index_tab  IN  1..WPLATOMATY_TMP.count LOOP
        --Dbms_Output.put_line('dataOperacji - argument metody: '||dataOperacji);
       wstawDaneSNO2(WPLATOMATY_TMP(index_tab), dataOperacji);
       licznik := licznik +1;
    END LOOP;
    
     error := 'close fh';
    IF UTL_FILE.is_open(prowizja_fh) THEN
         UTL_FILE.FCLOSE(prowizja_fh);
    END IF; 
    rvb := vision.pakpom.Zakoncz_Procesy_Log(licznik, 'OK; parametr wywolania -> miesiac: '|| miesiac|| ' rok: ' || rok, lacznaKwotaTransakcji );
    commit;
EXCEPTION
  WHEN blednyArgument THEN 
    dbms_output.put_line(sqlerrm || ' Niepoprawne wartosci dla argumentow meody');
    rvb := vision.pakpom.Zakoncz_Procesy_Log('00', 'NIEPOPRAWNY ARGUMENT METODY');
  WHEN brakDanych THEN 
    dbms_output.put_line(sqlerrm || ' Brak danych do przetworzenia..');
    rvb := vision.pakpom.Zakoncz_Procesy_Log('00', 'BRAK DANYCH');
  WHEN OTHERS THEN
    dbms_output.put_line(  error || sqlerrm);
    rvb := vision.pakpom.Zakoncz_Procesy_Log('00', 'BLAD');
end generujRaportSNO;

-------------------------------------------------------------------------------
end WPLATOMATY_PROCES;
